# 同义词管理与维护方案

## 一、同义词文件管理策略

### 1.1 版本控制

**Git 管理**：
```bash
# 目录结构
deploy/elasticsearch/analysis/
├── hotel_synonyms.txt           # 主同义词文件
├── hotel_synonyms_v1.txt        # 版本备份
├── hotel_synonyms_v2.txt        # 版本备份
└── CHANGELOG.md                 # 变更日志
```

**变更日志示例**：
```markdown
# 同义词变更日志

## v2.1 - 2025-11-13
### 新增
- 添加 20 个新开业酒店品牌
- 添加 10 个新商圈同义词

### 修改
- 修正"魔都"同义词映射（上海 -> 上海市）

### 删除
- 移除已关闭的品牌"XX酒店"

## v2.0 - 2025-11-01
...
```

---

### 1.2 分类管理

**按类别拆分文件**：
```bash
deploy/elasticsearch/analysis/
├── synonyms/
│   ├── city_synonyms.txt          # 城市同义词
│   ├── brand_synonyms.txt         # 品牌同义词
│   ├── facility_synonyms.txt      # 设施同义词
│   ├── landmark_synonyms.txt      # 地标同义词
│   └── transport_synonyms.txt     # 交通同义词
└── hotel_synonyms.txt              # 主文件（汇总）
```

**主文件引用子文件**（需要脚本合并）：
```bash
#!/bin/bash
# merge_synonyms.sh - 合并同义词文件

cat synonyms/city_synonyms.txt \
    synonyms/brand_synonyms.txt \
    synonyms/facility_synonyms.txt \
    synonyms/landmark_synonyms.txt \
    synonyms/transport_synonyms.txt \
    > hotel_synonyms.txt

echo "同义词文件合并完成"
```

---

## 二、数据来源与更新机制

### 2.1 数据来源

#### 1. 搜索日志分析（最重要）
```sql
-- 查询零结果的搜索词
SELECT 
    query_text,
    COUNT(*) as search_count
FROM search_logs
WHERE result_count = 0
    AND created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY query_text
HAVING search_count >= 5
ORDER BY search_count DESC
LIMIT 100;
```

**分析流程**：
1. 每周导出零结果查询词
2. 人工分析是否需要添加同义词
3. 添加到对应分类文件
4. 测试验证后发布

#### 2. 用户反馈
- 客服收集的用户搜索问题
- 用户投诉的搜索不准确问题
- A/B 测试反馈

#### 3. 业务数据
- 新开业酒店品牌
- 新建商圈/地标
- 新开通城市/机场
- 品牌更名/合并

#### 4. 竞品分析
- 参考携程、美团、飞猪等平台的同义词
- 行业标准术语

---

### 2.2 自动化更新流程

#### 方案 A：基于搜索日志的自动建议

**实现步骤**：

1. **创建同义词建议表**：
```sql
CREATE TABLE synonym_suggestions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    source_word VARCHAR(100) NOT NULL COMMENT '原词',
    target_word VARCHAR(100) NOT NULL COMMENT '目标词',
    suggestion_type ENUM('zero_result', 'user_feedback', 'manual') COMMENT '建议类型',
    search_count INT DEFAULT 0 COMMENT '搜索次数',
    confidence_score DECIMAL(5,2) COMMENT '置信度分数',
    status ENUM('pending', 'approved', 'rejected') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_by VARCHAR(50),
    reviewed_at TIMESTAMP,
    INDEX idx_status (status),
    INDEX idx_source (source_word)
) COMMENT '同义词建议表';
```

2. **定时任务分析零结果查询**：
```java
@Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点
public void analyzeZeroResultQueries() {
    // 1. 查询昨日零结果查询
    List<SearchLog> zeroResults = searchLogRepository.findZeroResultQueries(
        LocalDateTime.now().minusDays(1),
        LocalDateTime.now()
    );
    
    // 2. 分词并查找可能的同义词
    for (SearchLog log : zeroResults) {
        String query = log.getQueryText();
        
        // 尝试查找相似的有结果查询
        List<String> similarQueries = findSimilarSuccessfulQueries(query);
        
        for (String similar : similarQueries) {
            // 计算相似度
            double similarity = calculateSimilarity(query, similar);
            
            if (similarity > 0.7) {
                // 创建同义词建议
                SynonymSuggestion suggestion = new SynonymSuggestion();
                suggestion.setSourceWord(query);
                suggestion.setTargetWord(similar);
                suggestion.setSuggestionType("zero_result");
                suggestion.setConfidenceScore(similarity);
                suggestion.setSearchCount(log.getResultCount());
                
                synonymSuggestionRepository.save(suggestion);
            }
        }
    }
}
```

3. **管理后台审核界面**：
```java
@RestController
@RequestMapping("/admin/synonyms")
public class SynonymManagementController {
    
    /**
     * 获取待审核的同义词建议
     */
    @GetMapping("/suggestions/pending")
    public List<SynonymSuggestion> getPendingSuggestions() {
        return synonymSuggestionRepository.findByStatus("pending");
    }
    
    /**
     * 批准同义词建议
     */
    @PostMapping("/suggestions/{id}/approve")
    public void approveSuggestion(@PathVariable Long id) {
        SynonymSuggestion suggestion = synonymSuggestionRepository.findById(id)
            .orElseThrow();
        
        // 1. 更新状态
        suggestion.setStatus("approved");
        suggestion.setReviewedAt(LocalDateTime.now());
        synonymSuggestionRepository.save(suggestion);
        
        // 2. 添加到同义词文件
        appendToSynonymFile(suggestion);
        
        // 3. 重新加载 ES 分析器
        reloadElasticsearchAnalyzer();
    }
    
    /**
     * 批量导出为同义词文件格式
     */
    @GetMapping("/suggestions/export")
    public String exportApprovedSynonyms() {
        List<SynonymSuggestion> approved = synonymSuggestionRepository
            .findByStatus("approved");
        
        StringBuilder sb = new StringBuilder();
        for (SynonymSuggestion s : approved) {
            sb.append(s.getSourceWord())
              .append(" => ")
              .append(s.getTargetWord())
              .append("\n");
        }
        
        return sb.toString();
    }
}
```

---

#### 方案 B：基于点击率的同义词优化

**分析逻辑**：
```java
/**
 * 分析同义词效果
 * 如果某个同义词映射后的点击率很低，说明可能不准确
 */
@Scheduled(cron = "0 0 3 * * 0") // 每周日凌晨3点
public void analyzeSynonymEffectiveness() {
    // 1. 获取所有同义词映射
    Map<String, String> synonyms = loadSynonyms();
    
    // 2. 分析每个同义词的搜索效果
    for (Map.Entry<String, String> entry : synonyms.entrySet()) {
        String sourceWord = entry.getKey();
        String targetWord = entry.getValue();
        
        // 查询使用该同义词的搜索日志
        List<SearchLog> logs = searchLogRepository.findByQueryText(sourceWord);
        
        if (logs.isEmpty()) continue;
        
        // 计算点击率
        long totalSearches = logs.size();
        long clickedSearches = logs.stream()
            .filter(log -> log.getClickCount() > 0)
            .count();
        
        double clickRate = (double) clickedSearches / totalSearches;
        
        // 如果点击率过低，标记为需要审查
        if (clickRate < 0.1 && totalSearches > 50) {
            log.warn("同义词效果不佳: {} => {}, 点击率: {}", 
                sourceWord, targetWord, clickRate);
            
            // 创建审查任务
            createSynonymReviewTask(sourceWord, targetWord, clickRate);
        }
    }
}
```

---

## 三、同义词质量控制

### 3.1 添加前的验证

**验证清单**：
```java
public class SynonymValidator {
    
    /**
     * 验证同义词是否合理
     */
    public ValidationResult validate(String source, String target) {
        ValidationResult result = new ValidationResult();
        
        // 1. 检查是否已存在
        if (synonymExists(source, target)) {
            result.addError("同义词已存在");
        }
        
        // 2. 检查是否会造成循环映射
        if (hasCyclicMapping(source, target)) {
            result.addError("存在循环映射: " + source + " <-> " + target);
        }
        
        // 3. 检查语义相似度
        double similarity = calculateSemanticSimilarity(source, target);
        if (similarity < 0.5) {
            result.addWarning("语义相似度较低: " + similarity);
        }
        
        // 4. 测试搜索效果
        int beforeCount = searchHotels(source).size();
        int afterCount = searchHotels(target).size();
        
        if (afterCount == 0) {
            result.addError("目标词搜索结果为0");
        }
        
        result.setBeforeResultCount(beforeCount);
        result.setAfterResultCount(afterCount);
        
        return result;
    }
}
```

---

### 3.2 A/B 测试

**测试流程**：
```java
/**
 * 同义词 A/B 测试
 */
@Service
public class SynonymABTestService {
    
    /**
     * 创建 A/B 测试
     */
    public void createABTest(String synonymRule) {
        // 1. 创建测试组配置
        ABTestConfig config = new ABTestConfig();
        config.setTestName("synonym_test_" + System.currentTimeMillis());
        config.setControlGroup("current"); // 对照组：当前同义词
        config.setExperimentGroup("new");  // 实验组：新同义词
        config.setTrafficSplit(0.1);       // 10% 流量
        config.setDuration(7);             // 测试7天
        
        // 2. 为实验组创建临时索引别名
        createTemporaryIndex(config.getExperimentGroup(), synonymRule);
        
        // 3. 开始测试
        abTestRepository.save(config);
    }
    
    /**
     * 分析测试结果
     */
    public ABTestResult analyzeResults(String testName) {
        ABTestConfig config = abTestRepository.findByTestName(testName);
        
        // 对照组指标
        Metrics controlMetrics = calculateMetrics(
            config.getControlGroup(), 
            config.getStartTime(), 
            config.getEndTime()
        );
        
        // 实验组指标
        Metrics experimentMetrics = calculateMetrics(
            config.getExperimentGroup(), 
            config.getStartTime(), 
            config.getEndTime()
        );
        
        // 对比分析
        ABTestResult result = new ABTestResult();
        result.setClickRateImprovement(
            (experimentMetrics.getClickRate() - controlMetrics.getClickRate()) 
            / controlMetrics.getClickRate()
        );
        result.setZeroResultRateChange(
            experimentMetrics.getZeroResultRate() - controlMetrics.getZeroResultRate()
        );
        
        // 统计显著性检验
        result.setStatisticallySignificant(
            performTTest(controlMetrics, experimentMetrics)
        );
        
        return result;
    }
}
```

---

## 四、运维管理

### 4.1 热更新流程

**自动化脚本**：
```bash
#!/bin/bash
# update_synonyms.sh - 同义词热更新脚本

set -e

ES_HOST="localhost:9200"
INDEX_NAME="hotels_v1"
SYNONYM_FILE="/path/to/elasticsearch/config/analysis/hotel_synonyms.txt"
BACKUP_DIR="/path/to/backups"

echo "=== 同义词热更新开始 ==="

# 1. 备份当前同义词文件
BACKUP_FILE="$BACKUP_DIR/hotel_synonyms_$(date +%Y%m%d_%H%M%S).txt"
cp "$SYNONYM_FILE" "$BACKUP_FILE"
echo "✓ 已备份到: $BACKUP_FILE"

# 2. 验证新同义词文件格式
if ! grep -q "=>" "$SYNONYM_FILE"; then
    echo "✗ 同义词文件格式错误"
    exit 1
fi
echo "✓ 同义词文件格式验证通过"

# 3. 重新加载分析器
RELOAD_RESPONSE=$(curl -s -X POST "$ES_HOST/$INDEX_NAME/_reload_search_analyzers")
echo "✓ 分析器重新加载: $RELOAD_RESPONSE"

# 4. 测试同义词是否生效
TEST_QUERY='{"analyzer":"hotel_search_analyzer","text":"BJ酒店"}'
TEST_RESPONSE=$(curl -s -X POST "$ES_HOST/$INDEX_NAME/_analyze" \
    -H 'Content-Type: application/json' \
    -d "$TEST_QUERY")

if echo "$TEST_RESPONSE" | grep -q "北京"; then
    echo "✓ 同义词测试通过"
else
    echo "✗ 同义词测试失败，正在回滚..."
    cp "$BACKUP_FILE" "$SYNONYM_FILE"
    curl -s -X POST "$ES_HOST/$INDEX_NAME/_reload_search_analyzers"
    exit 1
fi

# 5. 记录变更
echo "$(date): 同义词更新成功" >> /var/log/synonym_updates.log

echo "=== 同义词热更新完成 ==="
```

**定时任务**：
```bash
# crontab -e
# 每天凌晨3点检查并更新同义词
0 3 * * * /path/to/update_synonyms.sh >> /var/log/synonym_updates.log 2>&1
```

---

### 4.2 监控告警

**监控指标**：
```java
@Component
public class SynonymMonitor {
    
    @Scheduled(fixedRate = 300000) // 每5分钟
    public void monitorSynonymHealth() {
        // 1. 检查同义词文件是否存在
        File synonymFile = new File(synonymFilePath);
        if (!synonymFile.exists()) {
            alertService.send("同义词文件不存在: " + synonymFilePath);
        }
        
        // 2. 检查文件大小变化
        long currentSize = synonymFile.length();
        long previousSize = getPreviousFileSize();
        
        if (Math.abs(currentSize - previousSize) > previousSize * 0.5) {
            alertService.send("同义词文件大小异常变化: " 
                + previousSize + " -> " + currentSize);
        }
        
        // 3. 检查零结果率
        double zeroResultRate = calculateZeroResultRate();
        if (zeroResultRate > 0.15) {
            alertService.send("零结果率过高: " + zeroResultRate);
        }
        
        // 4. 检查同义词命中率
        double synonymHitRate = calculateSynonymHitRate();
        if (synonymHitRate < 0.05) {
            alertService.send("同义词命中率过低: " + synonymHitRate);
        }
    }
}
```

---

## 五、最佳实践

### 5.1 同义词编写规范

**DO（推荐）**：
```
# ✓ 使用单向映射（避免误匹配）
BJ,Beijing => 北京
PEK,Capital Airport => 首都机场

# ✓ 按类别分组
# === 城市 ===
# === 品牌 ===

# ✓ 添加注释说明
# 北京的各种叫法
北京,BJ,Beijing,Peking

# ✓ 保持一致的格式
城市A,别名1,别名2 => 标准名称
```

**DON'T（不推荐）**：
```
# ✗ 避免双向映射（可能导致混乱）
北京,BJ  # 搜索"BJ"会匹配"北京"，搜索"北京"也会匹配"BJ"

# ✗ 避免过度扩展
酒店,宾馆,饭店,旅店,旅馆,客栈,民宿,青旅,招待所,度假村,Resort,Hotel,Inn,Motel

# ✗ 避免无意义的映射
酒店 => 酒店  # 无意义

# ✗ 避免循环映射
A => B
B => C
C => A
```

---

### 5.2 更新频率建议

| 同义词类型 | 更新频率 | 数据来源 |
|-----------|---------|---------|
| **城市/地标** | 每月 | 新开通城市、新地标 |
| **品牌** | 每周 | 新开业酒店、品牌更名 |
| **设施** | 每季度 | 行业标准变化 |
| **俚语/俗称** | 每周 | 搜索日志分析 |
| **紧急修复** | 随时 | 用户投诉、严重问题 |

---

### 5.3 团队协作

**角色分工**：
```
1. 数据分析师
   - 分析搜索日志
   - 发现零结果查询
   - 提出同义词建议

2. 产品经理
   - 审核同义词建议
   - 决定优先级
   - 协调业务需求

3. 开发工程师
   - 实现自动化工具
   - 执行同义词更新
   - 监控系统健康

4. 测试工程师
   - 验证同义词效果
   - 执行 A/B 测试
   - 回归测试

5. 运维工程师
   - 部署同义词更新
   - 监控系统性能
   - 处理告警
```

---

## 六、工具推荐

### 6.1 同义词管理后台

**功能清单**：
- [ ] 同义词 CRUD 操作
- [ ] 分类管理
- [ ] 版本控制
- [ ] 审核流程
- [ ] A/B 测试
- [ ] 效果分析
- [ ] 自动建议
- [ ] 批量导入/导出

**技术栈**：
- 前端：React + Ant Design
- 后端：Spring Boot
- 数据库：MySQL
- 缓存：Redis

---

### 6.2 监控大盘

**Grafana Dashboard**：
```json
{
  "panels": [
    {
      "title": "零结果率趋势",
      "type": "graph",
      "targets": [
        {
          "expr": "rate(search_zero_results_total[5m])"
        }
      ]
    },
    {
      "title": "同义词命中率",
      "type": "gauge",
      "targets": [
        {
          "expr": "synonym_hit_rate"
        }
      ]
    },
    {
      "title": "Top 10 零结果查询",
      "type": "table",
      "targets": [
        {
          "expr": "topk(10, search_zero_results_by_query)"
        }
      ]
    }
  ]
}
```

---

## 七、总结

### 核心原则
1. **数据驱动**：基于搜索日志和用户反馈
2. **小步快跑**：频繁小批量更新，而非大批量变更
3. **灰度发布**：使用 A/B 测试验证效果
4. **快速回滚**：保留备份，支持一键回滚
5. **持续优化**：定期分析效果，不断改进

### 关键指标
- **零结果率**：< 10%
- **同义词命中率**：> 5%
- **点击率提升**：> 10%
- **更新频率**：每周至少1次
- **审核时效**：< 24小时

### 长期目标
- 建立完善的同义词知识库
- 实现智能同义词推荐
- 构建行业领先的搜索体验

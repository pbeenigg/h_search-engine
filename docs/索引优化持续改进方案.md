# 酒店搜索引擎索引优化持续改进方案

## 一、当前架构分析

### 1.1 索引结构现状

**HotelIndexDoc 核心字段**：
- **基础字段**：tagSource, providerSource, hotelId
- **名称字段**：nameCn, nameEn（MultiField：Text + Keyword）
- **地理字段**：countryCn/En, cityCn/En, regionCn/En, continentCn/En, addressCn/En
- **坐标字段**：lat, lon, location（geo_point）
- **品牌字段**：groupCn/En, brandCn/En
- **描述字段**：descriptionCn/En

**NLP 衍生字段**：
- `nameTokens`：名称精细分词（Keyword 数组）
- `addressTokens`：地址精细分词（Keyword 数组）
- `nameKeywords`：名称关键词 TopK（Keyword 数组）
- `nerPlaces`：地点实体识别（Keyword 数组）
- `nerBrands`：品牌实体识别（Keyword 数组）
- `descriptionKeywords`：描述关键词 TopK（Keyword 数组）

### 1.2 搜索查询现状

**多通道召回策略**（HotelSearchQueryBuilder）：
1. **MultiMatch**：nameCn^5.0 + nameEn^3.0 + address^2.0
2. **拼音匹配**：nameCn.pinyin^2.0 + address.pinyin^1.8
3. **分词召回**：nameTokens^3.0
4. **关键词召回**：nameKeywords^4.0
5. **实体召回**：nerPlaces^3.0 + nerBrands^4.0

**问题点**：
- ❌ 拼音字段（pinyin）在索引中**未定义**，查询会失败
- ❌ descriptionKeywords 已生成但**未被查询使用**
- ❌ addressTokens 已生成但**未被查询使用**
- ❌ 缺少同义词、别名、简繁体处理
- ❌ 缺少用户搜索日志分析和反馈机制

---

## 二、索引优化方案（分阶段实施）

### 阶段一：修复现有问题（高优先级）

#### 1.1 修复拼音字段缺失问题

**问题**：查询中使用了 `nameCn.pinyin` 和 `address.pinyin`，但索引未定义。

**解决方案**：
```java
// HotelIndexDoc.java 修改
@MultiField(mainField = @Field(type = FieldType.Text, analyzer = "ik_max_word"),
        otherFields = {
                @InnerField(suffix = "keyword", type = FieldType.Keyword),
                @InnerField(suffix = "pinyin", type = FieldType.Text, analyzer = "pinyin_analyzer")
        })
private String nameCn;

@MultiField(mainField = @Field(type = FieldType.Text, analyzer = "ik_max_word"),
        otherFields = {
                @InnerField(suffix = "keyword", type = FieldType.Keyword),
                @InnerField(suffix = "pinyin", type = FieldType.Text, analyzer = "pinyin_analyzer")
        })
private String addressCn;
```

**配置拼音分析器**（需要在 ES 中配置）：
```json
{
  "settings": {
    "analysis": {
      "analyzer": {
        "pinyin_analyzer": {
          "tokenizer": "ik_max_word",
          "filter": ["pinyin_filter"]
        }
      },
      "filter": {
        "pinyin_filter": {
          "type": "pinyin",
          "keep_first_letter": true,
          "keep_full_pinyin": true,
          "keep_original": true,
          "limit_first_letter_length": 16,
          "lowercase": true
        }
      }
    }
  }
}
```

#### 1.2 启用已生成但未使用的字段

**修改 HotelSearchQueryBuilder**：
```java
// 添加地址分词召回
if (!qTokens.isEmpty()) {
    shoulds.add(terms("addressTokens", qTokens, (double) weights.getAddressTokensBoost()));
}

// 添加描述关键词召回
if (!qKeywords.isEmpty()) {
    shoulds.add(terms("descriptionKeywords", qKeywords, (double) weights.getDescKeywordsBoost()));
}
```

**配置权重**（HotelSearchWeights.java）：
```java
private float addressTokensBoost = 2.5f;
private float descKeywordsBoost = 1.5f;
```

---

### 阶段二：增强索引字段（中优先级）

#### 2.1 添加同义词支持
实现酒店名，城市/简称，景点/地标，交通/区域，品牌/集团匹配   （通过 HanLP    自定义同义词实现）
**新增字段**：
```java
// HotelIndexDoc.java
@Field(type = FieldType.Keyword)
private List<String> nameSynonyms;  // 名称同义词（如：希尔顿 -> Hilton）

@Field(type = FieldType.Keyword)
private List<String> citySynonyms;  // 城市别名（如：北京 -> BJ, Beijing）
```



#### 2.2 添加简繁体转换字段

**新增字段**：
```java
@Field(type = FieldType.Text)
private String nameSimplified;  // 简体中文名称

@Field(type = FieldType.Text)
private String nameTraditional;  // 繁体中文名称
```

**生成逻辑**：
```java
d.setNameSimplified(NLP.toSimplified(d.getNameCn()));
d.setNameTraditional(NLP.toTraditional(d.getNameCn()));
```

#### 2.3 添加热度/评分字段

**新增字段**：
```java
@Field(type = FieldType.Integer)
private Integer popularityScore;  // 热度分数（基于搜索次数）

@Field(type = FieldType.Float)
private Float userRating;  // 用户评分

@Field(type = FieldType.Integer)
private Integer reviewCount;  // 评论数量

@Field(type = FieldType.Date)
private OffsetDateTime lastBookedAt;  // 最后预订时间
```

**用途**：用于 Function Score 加权排序。

---

### 阶段三：优化分词和NLP处理（中优先级）

#### 3.1 优化分词过滤逻辑

**当前问题**：
- 已实现：过滤单字符、去重（大小写不敏感）
- 未实现：停用词过滤、无意义词过滤

**改进方案**：
```java
// 添加停用词列表
private static final Set<String> STOP_WORDS = Set.of(
    "的", "了", "在", "是", "我", "有", "和", "就", "不", "人",
    "都", "一", "一个", "上", "也", "很", "到", "说", "要", "去",
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to"
);

private boolean isStopWord(String token) {
    return STOP_WORDS.contains(token.toLowerCase());
}

// 在 filterValidTokens 中添加
.filter(token -> !isStopWord(token))
```

#### 3.2 增强品牌识别

**问题**：当前 `nerBrands` 使用 HanLP 的组织识别（Nature.nt），但酒店品牌识别效果不佳。

**改进方案  自定义HanLP品牌词典**：

## 词典说明
本章详细介绍HanLP中的词典格式，满足用户自定义的需要。HanLP中有许多词典，它们的格式都是相似的，形式都是文本文档，随时可以修改。
### 基本格式
词典分为词频词性词典和词频词典。

- 词频词性词典（如`CoreNatureDictionary.txt`）
    * 每一行代表一个单词，格式遵从`[单词] [词性A] [A的频次] [词性B] [B的频次] ...`。
    * 支持省略词性和频次，直接一行一个单词。
    * `.txt`词典文件的分隔符为空格或制表符，所以不支持含有空格的词语。如果需要支持空格，请使用英文逗号`,`分割的**纯文本**`.csv`文件。在使用Excel等富文本编辑器时，则请注意保存为**纯文本**形式。
- 词频词典（如`CoreNatureDictionary.ngram.txt`）
    * 每一行代表一个单词或条目，格式遵从`[单词] [单词的频次]`。
    * 每一行的分隔符为空格或制表符。

少数词典有自己的专用格式，比如同义词词典兼容《同义词词林扩展版》的文本格式，而转移矩阵词典则是一个csv表格。

下文主要介绍通用词典，如不注明，词典特指通用词典。

### 储存形式

词典有两个形态：文本文件(filename.txt)和缓存文件(filename.txt.bin或filename.txt.trie.dat和filename.txt.trie.value)。

- 文本文件
    * 采用明文储存，UTF-8编码，CRLF换行符。
- 缓存文件
    * 就是一些二进制文件，通常在文本文件的文件名后面加上.bin表示。有时候是.trie.dat和.trie.value。后者是历史遗留产物，分别代表trie树的数组和值。
    * 如果你修改了任何词典，只有删除缓存才能生效。



#### 3.3 添加地理层级字段

**新增字段**：
```java
@Field(type = FieldType.Keyword)
private List<String> geoHierarchy;  // 地理层级：["亚洲", "中国", "上海", "浦东新区"]
```

**生成逻辑**：
```java
List<String> hierarchy = new ArrayList<>();
if (d.getContinentCn() != null) hierarchy.add(d.getContinentCn());
if (d.getCountryCn() != null) hierarchy.add(d.getCountryCn());
if (d.getCityCn() != null) hierarchy.add(d.getCityCn());
if (d.getRegionCn() != null) hierarchy.add(d.getRegionCn());
d.setGeoHierarchy(hierarchy);
```

---

### 阶段四：搜索质量监控与优化（持续任务）

#### 4.1 搜索日志收集
日志收集基于 **Redis Stream + Camel 路由** 的高性能异步架构。  
1. **非阻塞**：通过 Redis Stream 异步收集，搜索响应时间不受影响
2. **高吞吐**：批量消费和批量插入，性能提升 10-20 倍
3. **高可靠**：Redis Stream 提供持久化和消费者组机制
4. **可扩展**：可轻松增加消费者实例，水平扩展

**新增实体**：
```java
@Entity
@Table(name = "search_logs")
public class SearchLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String query;           // 用户查询词
    private String tagSource;       // 业务域
    private Integer resultCount;    // 结果数量
    private Long clickedHotelId;    // 点击的酒店ID
    private Integer clickPosition;  // 点击位置
    private Long durationMs;        // 查询耗时
    private OffsetDateTime createdAt;
}
```



#### 4.2 零结果查询分析

**定时任务**：
```java
@Scheduled(cron = "0 0 2 * * ?")  // 每天凌晨2点
public void analyzeZeroResultQueries() {
    List<SearchLog> zeroResults = searchLogRepository
        .findByResultCountAndCreatedAtAfter(0, OffsetDateTime.now().minusDays(1));
    
    // 分析高频零结果查询
    Map<String, Long> queryFreq = zeroResults.stream()
        .collect(Collectors.groupingBy(SearchLog::getQuery, Collectors.counting()));
    
    // 发送告警邮件
    if (!queryFreq.isEmpty()) {
        mailNotifier.sendText(
            "零结果查询分析报告",
            "高频零结果查询：\n" + queryFreq.entrySet().stream()
                .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
                .limit(20)
                .map(e -> e.getKey() + ": " + e.getValue() + "次")
                .collect(Collectors.joining("\n"))
        );
    }
}
```

#### 4.3 搜索质量指标监控

**关键指标**：
1. **召回率**：有结果的查询占比
2. **点击率（CTR）**：有点击的查询占比
3. **平均点击位置**：点击结果的平均排名
4. **查询耗时**：P50, P95, P99
5. **零结果率**：无结果查询占比

**监控面板**：
```java
@RestController
@RequestMapping("/api/search/metrics")
public class SearchMetricsController {
    
    @GetMapping("/summary")
    public Map<String, Object> getMetrics(@RequestParam String startDate, @RequestParam String endDate) {
        List<SearchLog> logs = searchLogRepository.findByCreatedAtBetween(
            OffsetDateTime.parse(startDate), OffsetDateTime.parse(endDate));
        
        long totalQueries = logs.size();
        long zeroResults = logs.stream().filter(l -> l.getResultCount() == 0).count();
        long withClicks = logs.stream().filter(l -> l.getClickedHotelId() != null).count();
        double avgClickPosition = logs.stream()
            .filter(l -> l.getClickPosition() != null)
            .mapToInt(SearchLog::getClickPosition)
            .average().orElse(0);
        
        return Map.of(
            "totalQueries", totalQueries,
            "zeroResultRate", (double) zeroResults / totalQueries,
            "clickThroughRate", (double) withClicks / totalQueries,
            "avgClickPosition", avgClickPosition
        );
    }
}
```

---

### 阶段五：高级优化（低优先级）

#### 5.1 个性化搜索

**用户画像字段**：
```java
@Entity
public class UserSearchProfile {
    private Long userId;
    private List<String> preferredCities;      // 常搜城市
    private List<String> preferredBrands;      // 偏好品牌
    private String preferredPriceRange;        // 价格区间
    private OffsetDateTime lastSearchAt;
}
```

**个性化加权**：
```java
// 基于用户画像调整权重
if (userProfile != null && userProfile.getPreferredBrands().contains(brand)) {
    boost *= 1.5;  // 偏好品牌加权
}
```

#### 5.2 智能纠错和建议

**拼写纠错**：
```java
public List<String> suggestCorrections(String query) {
    // 使用 ES 的 Suggest API
    return esClient.suggest(s -> s
        .index("hotels_read")
        .suggesters("name_suggestion", su -> su
            .text(query)
            .term(t -> t.field("nameCn"))
        ), Void.class).suggest().get("name_suggestion").stream()
        .flatMap(s -> s.term().options().stream())
        .map(o -> o.text())
        .collect(Collectors.toList());
}
```

#### 5.3 相关性调优（Learning to Rank）

**收集训练数据**：
- 查询词 + 点击酒店 = 正样本
- 查询词 + 展示但未点击酒店 = 负样本

**特征工程**：
- BM25 分数
- 字段匹配度
- 地理距离
- 热度分数
- 用户偏好匹配度

---

## 三、实施优先级和时间规划

### 第一周：修复现有问题
- [ ] 修复拼音字段缺失（配置 ES 分析器）
- [ ] 启用 addressTokens 和 descriptionKeywords 查询
- [ ] 添加停用词过滤

### 第二周：增强基础能力
- [ ] 实现品牌词典匹配
- [ ] 添加简繁体转换字段
- [ ] 实现地理层级字段

### 第三周：搜索质量监控
- [ ] 实现搜索日志收集
- [ ] 实现零结果查询分析
- [ ] 搭建监控面板

### 第四周及以后：持续优化
- [ ] 基于日志分析优化权重配置
- [ ] 实现同义词词典
- [ ] 添加热度/评分字段
- [ ] 探索个性化搜索

---

## 四、关键配置参数调优建议

### 4.1 当前权重配置
```yaml
heytrip:
  search:
    name-cn-boost: 5.0
    name-en-boost: 3.0
    address-boost: 2.0
    pinyin-boost: 2.0
    address-pinyin-boost: 1.8
    tokens-boost: 3.0
    keywords-boost: 4.0
    ner-places-boost: 3.0
    ner-brands-boost: 4.0
```

### 4.2 建议调整
```yaml
heytrip:
  search:
    # 名称权重最高（用户最关注）
    name-cn-boost: 6.0          # 提高中文名称权重
    name-en-boost: 4.0          # 提高英文名称权重
    
    # 关键词和品牌次之
    keywords-boost: 5.0         # 提高关键词权重
    ner-brands-boost: 5.0       # 提高品牌识别权重
    
    # 地址和地点
    address-boost: 2.5
    ner-places-boost: 3.5       # 提高地点识别权重
    address-tokens-boost: 2.5   # 新增
    
    # 拼音和分词
    pinyin-boost: 2.5           # 提高拼音权重
    address-pinyin-boost: 2.0
    tokens-boost: 3.5           # 提高分词权重
    
    # 描述（权重最低）
    desc-keywords-boost: 1.5    # 新增
    
    # 最小匹配策略
    minimum-should-match: "2"   # 至少匹配2个条件（提高精准度）
```

---

## 五、监控和告警

### 5.1 关键指标告警阈值
- **零结果率 > 10%**：触发告警
- **平均查询耗时 > 500ms**：触发告警
- **点击率 < 30%**：触发告警
- **索引失败率 > 1%**：触发告警

### 5.2 日志记录
```java
// 在 HotelSearchService 中增强日志
log.info("[SEARCH] q='{}' total={} durationMs={} hasClick={} clickPosition={}", 
    q, total, durMs, hasClick, clickPosition);
```

---

## 六、总结

### 核心优化方向
1. **修复现有问题**：拼音字段、未使用字段
2. **增强召回能力**：同义词、简繁体、品牌词典
3. **提升排序质量**：热度分数、用户评分、Function Score
4. **持续监控优化**：搜索日志、零结果分析、A/B测试

### 预期效果
- **召回率提升 15-20%**
- **零结果率降低 30-40%**
- **点击率提升 10-15%**
- **平均点击位置前移 2-3 位**

### 长期目标
建立**数据驱动的搜索优化闭环**：
```
用户搜索 → 日志收集 → 数据分析 → 发现问题 → 优化策略 → 效果验证 → 持续迭代
```

# 认证授权功能使用指南

## 一、功能概述

本系统实现了基于 **Sa-Token** 的双重认证授权机制：

### 认证模式

1. **Token 认证模式**：用户通过账号密码登录，获取 Token 进行后续请求认证
2. **APP 签名认证模式**：第三方系统通过 AppID + SecretKey + 时间戳签名进行认证

### 核心功能

- ✅ 用户增删改查
- ✅ 应用增删改查
- ✅ 密码 BCrypt 加密
- ✅ APP 签名验证（MD5 + 时间戳防重放）
- ✅ **Redis 缓存** Token 和 App 信息
- ✅ **Redisson 分布式锁**防止并发创建用户
- ✅ **智能限流**：基于 `rate_limit` 字段，同请求+同参数才触发

---

## 二、快速开始

### 2.1 初始化数据库

```bash
mysql -u root -p < db/mysql/login.sql
```

执行后会创建：
- `user` 表
- `app` 表
- 默认管理员账号：`admin / admin123`

### 2.2 启动应用

```bash
cd backend
mvn clean package -DskipTests
java -jar app/target/hotel-search-app-*.jar
```

### 2.3 访问 Swagger 文档

```
http://localhost:18080/swagger-ui.html
```

---

## 三、API 接口说明

### 3.1 认证接口 `/auth`

#### 登录
```bash
POST /auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}
```

**响应**：
```json
{
  "code": 200,
  "msg": "操作成功",
  "data": {
    "tokenName": "Authorization",
    "tokenValue": "a3b2c1d4-e5f6-7890-abcd-ef1234567890",
    "userId": 1,
    "userName": "admin",
    "userNick": "系统管理员"
  },
  "timestamp": 1734507600000
}
```

#### 登出
```bash
POST /auth/logout
Authorization: {tokenValue}
```

#### 获取当前用户信息
```bash
GET /auth/current
Authorization: {tokenValue}
```

---

### 3.2 用户管理接口 `/user`

#### 创建用户
```bash
POST /user
Authorization: {tokenValue}
Content-Type: application/json

{
  "userName": "test_user",
  "password": "Test@123456",
  "userNick": "测试用户",
  "sex": "M"
}
```

**说明**：
- 自动生成对应的 App 记录
- `app_id` 格式：`{userName}_{timestamp}`
- `secret_key` 自动生成 UUID

#### 更新用户
```bash
PUT /user/{userId}
Authorization: {tokenValue}
Content-Type: application/json

{
  "userNick": "新昵称",
  "sex": "F"
}
```

#### 修改密码
```bash
POST /user/{userId}/change-password
Authorization: {tokenValue}
Content-Type: application/json

{
  "oldPassword": "Test@123456",
  "newPassword": "NewPass@123"
}
```

#### 删除用户
```bash
DELETE /user/{userId}
Authorization: {tokenValue}
```

**说明**：级联删除关联的 App 记录

#### 查询用户
```bash
GET /user/{userId}
Authorization: {tokenValue}
```

#### 用户列表
```bash
GET /user?page=0&size=20
Authorization: {tokenValue}
```

---

### 3.3 应用管理接口 `/app`

#### 查询应用详情
```bash
GET /app/{appId}
Authorization: {tokenValue}
```

**响应示例**：
```json
{
  "code": 200,
  "data": {
    "appId": "test_user_1734507600000",
    "secretKey": "a1b2c3d4e5f67890abcdef1234567890",
    "encryptionKey": "f1e2d3c4b5a67890fedcba9876543210",
    "rateLimit": 1000,
    "timeout": -1,
    "createAt": "2024-12-18T10:00:00",
    "updateAt": "2024-12-18T10:00:00"
  }
}
```

#### 应用列表
```bash
GET /app?page=0&size=20
Authorization: {tokenValue}
```

#### 更新应用配置
```bash
PUT /app/{appId}
Authorization: {tokenValue}
Content-Type: application/json

{
  "rateLimit": 2000,
  "timeout": 720
}
```

#### 刷新应用密钥
```bash
POST /app/{appId}/refresh-secret
Authorization: {tokenValue}
```

**说明**：重新生成 `secret_key`，用于密钥泄露后的应急处理

---

## 四、APP 签名认证使用

### 4.1 签名规则

```
sign = MD5("app" + {appId} + "secret" + {secretKey} + "timestamp" + {秒级时间戳})
```

### 4.2 请求示例（Bash）

```bash
#!/bin/bash

# 配置（从数据库获取）
APP_ID="test_user_1734507600000"
SECRET_KEY="a1b2c3d4e5f67890abcdef1234567890"

# 生成时间戳（秒级）
TIMESTAMP=$(date +%s)

# 计算签名
SIGN=$(echo -n "app${APP_ID}secret${SECRET_KEY}timestamp${TIMESTAMP}" | md5sum | awk '{print $1}')

# 发起请求
curl -X GET "http://localhost:18080/user" \
  -H "app: $APP_ID" \
  -H "sign: $SIGN" \
  -H "timestamp: $TIMESTAMP"
```

### 4.3 签名示例（Java）

```java
import cn.hutool.crypto.digest.DigestUtil;

public class AppSignDemo {
    public static void main(String[] args) {
        String appId = "test_user_1734507600000";
        String secretKey = "a1b2c3d4e5f67890abcdef1234567890";
        long timestamp = System.currentTimeMillis() / 1000;
        
        String raw = "app" + appId + "secret" + secretKey + "timestamp" + timestamp;
        String sign = DigestUtil.md5Hex(raw);
        
        System.out.println("app: " + appId);
        System.out.println("sign: " + sign);
        System.out.println("timestamp: " + timestamp);
    }
}
```

### 4.4 签名示例（Python）

```python
import hashlib
import time

app_id = "test_user_1734507600000"
secret_key = "a1b2c3d4e5f67890abcdef1234567890"
timestamp = int(time.time())

raw = f"app{app_id}secret{secret_key}timestamp{timestamp}"
sign = hashlib.md5(raw.encode()).hexdigest()

print(f"app: {app_id}")
print(f"sign: {sign}")
print(f"timestamp: {timestamp}")
```

---

## 五、限流机制说明

### 5.1 限流策略

- **限流单位**：每分钟请求次数
- **限流维度**：`appId` + `requestKey`
- **requestKey 生成规则**：`MD5(METHOD:URI:PARAMS:BODY)`

**关键特性**：
- ✅ **同请求+同参数才触发限流**
- ✅ 不同参数的请求不相互影响
- ✅ 基于 Redisson `RRateLimiter` 实现
- ✅ 限流阈值从 `app.rate_limit` 字段读取

### 5.2 限流示例

假设 `app.rate_limit = 1000`（每分钟 1000 次）

```bash
# 请求 1：GET /user?page=0&size=10
# requestKey = MD5("GET:/user:page=0&size=10:")
# 限流计数器：appId_requestKey1 = 1

# 请求 2：GET /user?page=0&size=10（相同请求）
# 限流计数器：appId_requestKey1 = 2

# 请求 3：GET /user?page=1&size=10（不同参数）
# requestKey = MD5("GET:/user:page=1&size=10:")
# 限流计数器：appId_requestKey2 = 1（独立计数）
```

### 5.3 限流响应

当超过限流阈值时：
```json
{
  "code": 429,
  "msg": "请求过于频繁，请稍后再试",
  "timestamp": 1734507600000
}
```

---

## 六、Redis 缓存机制

### 6.1 缓存策略

| 缓存类型 | Key 格式 | TTL | 用途 |
|---------|---------|-----|------|
| App 缓存 | `auth:app:{appId}` | 30分钟 | 签名验证时读取 |
| User 缓存 | `auth:user:{userName}` | 30分钟 | 登录验证时读取 |

### 6.2 缓存更新时机

- **创建**：自动写入缓存
- **更新**：自动清除缓存（下次访问重建）
- **删除**：自动清除缓存

---

## 七、分布式锁机制

### 7.1 使用场景

创建用户时使用分布式锁，防止并发创建相同用户名：

```java
String lockKey = "lock:user:create:" + userName;
RLock lock = redissonClient.getLock(lockKey);

try {
    boolean locked = lock.tryLock(5, 10, TimeUnit.SECONDS);
    if (!locked) {
        throw new BusinessException("系统繁忙，请稍后重试");
    }
    
    // 检查用户名是否存在
    // 创建用户逻辑
    
} finally {
    if (lock.isHeldByCurrentThread()) {
        lock.unlock();
    }
}
```

### 7.2 锁参数说明

- **waitTime**：5秒（等待获取锁的最大时间）
- **leaseTime**：10秒（锁自动释放时间，防止死锁）

---

## 八、安全防护措施

### 8.1 密码安全

- ✅ BCrypt 加密存储（$2a$10$...）
- ✅ 登录时密码明文验证，不暴露加密密码

### 8.2 签名防护

- ✅ MD5 签名防篡改
- ✅ 时间戳防重放（默认 10 秒窗口）
- ✅ Secret Key 随机生成（UUID）

### 8.3 SQL 注入防护

- ✅ JPA + PreparedStatement 自动防注入

### 8.4 异常处理

- ✅ 全局异常统一返回格式
- ✅ 敏感信息不暴露

---

## 九、配置说明

### 9.1 application.yml 配置

```yaml
# Sa-Token 配置
sa-token:
  token-name: Authorization        # Token 名称
  timeout: 86400                   # Token 过期时间（秒）24小时
  activity-timeout: 1800           # Token 活跃超时（秒）30分钟
  is-concurrent: true              # 允许并发登录
  is-share: false                  # 不共享 Token
  token-style: uuid                # Token 风格（uuid）
  is-log: false                    # 关闭日志

# 认证配置
auth:
  exclude-paths:                   # 白名单路径
    - /auth/**
    - /health
    - /actuator/**
    - /swagger-ui/**
    - /v3/api-docs/**
  sign-timeout-seconds: 10         # 签名时间戳允许偏差（秒）

# Redis 配置
spring:
  data:
    redis:
      host: localhost
      port: 6379
      password: 
      database: 0
```

---

## 十、故障排查

### 10.1 Token 认证失败

**现象**：`401 - 用户未登录`

**排查**：
1. 检查 Header：`Authorization: {tokenValue}`
2. 检查 Token 是否过期
3. 查看 Sa-Token 日志

### 10.2 APP 签名验证失败

**现象**：`401 - 签名验证失败`

**排查**：
1. 检查签名算法是否正确
2. 检查时间戳是否在允许范围内（±10秒）
3. 检查 `appId` 和 `secretKey` 是否匹配
4. 查看日志：`AppSignInterceptor`

### 10.3 限流触发

**现象**：`429 - 请求过于频繁`

**排查**：
1. 检查 `app.rate_limit` 配置
2. 检查是否重复发送相同请求
3. 调整限流阈值

### 10.4 Redis 连接失败

**现象**：服务启动失败或缓存不生效

**排查**：
1. 检查 Redis 是否启动
2. 检查 `application-dev.yml` Redis 配置
3. 测试 Redis 连接：`redis-cli ping`

---

## 十一、性能优化建议

### 11.1 缓存优化

- Redis 缓存 30 分钟，减少数据库查询
- 更新/删除时自动清除缓存

### 11.2 数据库优化

- `user_name` 添加唯一索引
- `app_id` 添加索引
- 外键约束确保数据一致性

### 11.3 限流优化

- 合理设置 `rate_limit` 值
- 监控限流触发频率
- 区分不同接口的限流策略（扩展）

---




